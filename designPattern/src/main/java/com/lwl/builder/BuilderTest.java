/**
 * 建造者模式，又称生成器模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。
	 三个角色：		建造者、具体的建造者、监工、使用者（严格来说不算）
	 建造者角色：	定义生成实例所需要的所有方法；
	 具体的建造者角色：实现生成实例所需要的所有方法，并且定义获取最终生成实例的方法；
	 监工角色：		定义使用建造者角色中的方法来生成实例的方法；
	 使用者：		使用建造者模式。
	注意：定义中“将一个复杂的构建过程与其表示相分离”，表示并不是由建造者负责一切，而是由监工负责控制（定义）一个复杂的构建过程，
	由各个不同的建造者分别负责实现构建过程中所用到的所有构建步骤。不然，就无法做到“使得同样的构建过程可以创建不同的表示”这一目标。
 */
/**
 * 上述文字太拗口和抽象了，下面做个简单的例子说明
 * 当你有一个接口，自定义了多个方法，现在有个类实现了该接口，那么创建这个类的时候需要将所有的方法或者部分方法合并到一个方法里面，2种实现方式
 * 第一种：在实现类里面自定义新的方法，然后将其他方法合并到新的方法里面，缺点就是：如果有多个类实现该接口，那么都要自定义新的方法和逻辑
 * 第二种：通过一个构造类去，传入接口对象，然后定义方法，实现上面类的初始化过程，很明显面向接口的编程，可以达到代码的复用性，这个就是建造者模式
 * 
 * 
 */
package com.lwl.builder;
/***
 * 建造者模式  和 代理模式的区别在于：
 * 	建造者模式： 是别人把他所需要的过程组装成一个方法，具体的每个方法都是要建造者自己实现
 * 	代理模式：被代理的类只关注自己的方法，代理类会新增自己的方法，用于在被代理的类的方法前后
 */
/**
 * 建造者模式
 * @author lwl
 * @create 2019年1月4日 上午8:23:51
 * @version 1.0
 */
public class BuilderTest {

	public static void main(String[] args) {

		PersonBuilder builder = new PersonBuilder();//建造者
		
		Director director = new Director(builder);//监工
		
		director.builder();//建造实例(监工负责监督，建造者实际建造)
		
		String result = builder.getResult();////获取最终生成结果
		
		System.out.println();
		System.out.println(result);
		
	}
}
